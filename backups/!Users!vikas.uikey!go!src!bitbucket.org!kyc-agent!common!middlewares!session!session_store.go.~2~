package session

import (
	"encoding/base32"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strings"

	kycRedis "bitbucket.org/kyc-agent/common/redis"
	redis "github.com/chasex/redis-go-cluster"
	"github.com/gorilla/securecookie"
	"github.com/gorilla/sessions"
)

type RedisStore struct {
	conn          *redis.Cluster
	Codecs        []securecookie.Codec
	Options       *sessions.Options // default configuration
	DefaultMaxAge int               // default Redis TTL for a MaxAge == 0 session
	maxLength     int
	keyPrefix     string
	serializer    SessionSerializer
}

var sessionExpire = 86400 * 30

func NewRedisStore(conn *redis.Cluster, keyPairs ...[]byte) *RedisStore {

	rs := &RedisStore{
		conn:   conn,
		Codecs: securecookie.CodecsFromPairs(keyPairs...),
		Options: &sessions.Options{
			Path:   "/",
			MaxAge: sessionExpire,
		},
		DefaultMaxAge: 24 * 60 * 60,
		keyPrefix:     "session_",
		serializer:    GobSerializer{},
	}

	return rs
}

func (s *RedisStore) SetMaxAge(v int) {
	var c *securecookie.SecureCookie
	var ok bool
	s.Options.MaxAge = v
	for i := range s.Codecs {
		if c, ok = s.Codecs[i].(*securecookie.SecureCookie); ok {
			c.MaxAge(v)
		} else {
			fmt.Printf("Can't change MaxAge on codec %v\n", s.Codecs[i])
		}
	}
}

func (s *RedisStore) SetOptions(options *sessions.Options) {
	s.Options = &sessions.Options{
		Path:     options.Path,
		Domain:   options.Domain,
		MaxAge:   options.MaxAge,
		Secure:   options.Secure,
		HttpOnly: options.HttpOnly,
	}
}

// New should create and return a new session. see gorilla session library
func (s *RedisStore) New(r *http.Request, name string) (*sessions.Session, error) {

	var (
		err error
		ok  bool
	)

	session := sessions.NewSession(s, name)
	options := *s.Options
	session.Options = &options
	session.IsNew = true

	if c, errCookie := r.Cookie(name); errCookie == nil {
		err = securecookie.DecodeMulti(name, c.Value, &session.ID, s.Codecs...)
		if err != nil {
			ok, err = s.load(session)
			if ok {
				session.IsNew = !(err == nil && ok)
			}
		}
	}

	return session, err
}

// function to save session in redis and in http headers
func (s *RedisStore) Save(r *http.Request, w http.ResponseWriter, session *sessions.Session) error {
	// marked for deletion
	if session.Options.MaxAge < 0 {
		if err := s.delete(session); err != nil {
			return err
		}

		// reset cookie to empty in http header
		http.SetCookie(w, sessions.NewCookie(session.Name(), "", session.Options))
	} else {

		// set session id
		if session.ID == "" {
			session.ID = strings.TrimRight(base32.StdEncoding.EncodeToString(securecookie.GenerateRandomKey(32)), "=")
		}

		// save session in redis
		if err := s.save(session); err != nil {
			return err
		}

		// encode cookie to set in http header
		encoded, err := securecookie.EncodeMulti(session.Name(), session.ID, s.Codecs...)
		if err != nil {
			return err
		}
		log.Println("setting response header")
		http.SetCookie(w, sessions.NewCookie(session.Name(), encoded, session.Options))
	}

	return nil
}

func (s *RedisStore) Get(r *http.Request, name string) (*sessions.Session, error) {
	return sessions.GetRegistry(r).Get(s, name)
}

func (s *RedisStore) delete(session *sessions.Session) error {
	redisKey := s.keyPrefix + session.ID
	err := kycRedis.Delete(redisKey)
	return err
}

func (s *RedisStore) load(session *sessions.Session) (bool, error) {

	redisKey := s.keyPrefix + session.ID
	data, err := kycRedis.Get(redisKey)

	if err != nil {
		return false, err
	}

	if data == nil {
		return false, errors.New("SessionStore: No session data found")
	}

	return true, s.serializer.Deserialize(data, session)
}

func (s *RedisStore) save(session *sessions.Session) error {

	sessionBytes, err := s.serializer.Serialize(session)
	if err != nil {
		return err
	}

	if s.maxLength != 0 && len(sessionBytes) > s.maxLength {
		return errors.New("SessionStore: the value to store is to big")
	}

	age := session.Options.MaxAge
	if age == 0 {
		// set default max age for session key expiry
		age = s.DefaultMaxAge
	}

	redisKey := s.keyPrefix + session.ID
	saveErr := kycRedis.SetEx(redisKey, int64(age), sessionBytes)
	return saveErr
}
