package funnel

import (
	"encoding/json"
	"fmt"
	"github.com/gorilla/mux"
	"github.com/gorilla/schema"
	"github.com/saiser/rpcx/log"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"sync"
)

var (
	decoder *schema.Decoder

	requiredFieldsLock  sync.RWMutex
	requiredFieldsCache map[string][]string
)

const (
	requestIDKey = "X-Request-ID"
)

type ApiRequestDTO interface {
	GetErrors() error
}

type stdRequestHandler func(http.ResponseWriter, *http.Request, ApiRequestDTO) (int, []byte)

// InitDecoder initialises the decoder object
func InitDecoder() {
	// create and configure the decoder
	decoder = schema.NewDecoder()
	decoder.IgnoreUnknownKeys(true)
	decoder.SetAliasTag("json")

	requiredFieldsCache = make(map[string][]string)
}

func ApiHandler(requestHandler stdRequestHandler, requestDTO ApiRequestDTO) http.HandlerFunc {

	return processApiHandler(requestHandler, requestDTO)
}

func processApiHandler(requestHandler stdRequestHandler, requestDTO ApiRequestDTO) http.HandlerFunc {

	handlerProcessor := func(resp http.ResponseWriter, req *http.Request) {
		var responseBody []byte
		var code int

		// set requestId MiddleWare
		setRequestId(req)
		parsedRequest, parseReqErr := parseRequest(req, requestDTO, mux.Vars(req))

		if parseReqErr != nil {
			resp.WriteHeader(http.StatusBadRequest)
		}

		// execute actual api handler passed
		code, responseBody = requestHandler(resp, req, parsedRequest)
		setResponseContentType(resp, req)

		// Write Response
		resp.WriteHeader(code)
		resp.Write(responseBody)
	}

	return handlerProcessor
}

func setResponseContentType(resp http.ResponseWriter, req *http.Request) {

	if resp.Header().Get("Content-Type") == "" {
		resp.Header().Set("Content-Type", "application/json")
	}
}

func parseRequest(req *http.Request, requestDTO ApiRequestDTO, data map[string]string) (ApiRequestDTO, error) {

	if requestDTO == nil {
		return nil, nil
	}

	// parse url parameter passed, then parse the response packet for the POST body (request body)
	if err := req.ParseForm(); err != nil {
		log.Warn("unexpected error while parsing form. err: %s", err)
		return nil, err
	}

	dtoType := reflect.TypeOf(requestDTO)

	requestDto, _ := reflect.New(dtoType.Elem()).Interface().(ApiRequestDTO)

	// attention: If you do not call ParseForm method, the following data can not be obtained form
	errs := Decode(requestDto, req, data)
	if errs != nil {
		return nil, errs
	}

	return requestDto, nil
}

func Decode(object ApiRequestDTO, req *http.Request, data map[string]string) error {

	if req.Form == nil {
		req.Form = url.Values{}
	}

	// parse the json body
	contentType := req.Header.Get("Content-Type")
	if strings.HasPrefix(contentType, "application/json") && req.ContentLength > 0 {
		jsonDecoder := json.NewDecoder(req.Body)
		decodingErr := jsonDecoder.Decode(object)
		if decodingErr != nil {
			log.Error("Error occurred while decoding request body", decodingErr)
			return decodingErr
		}
	}

	// fill req.Form with mux vars
	if data != nil {
		for key, val := range data {
			req.Form.Set(key, val)
		}
	}

	// check required fields passed or not
	if req.Method == "GET" {
		if requiredErr := checkRequiredField(object, req.Form); requiredErr != nil {
			return requiredErr
		}
	}

	// decode using schema decoder
	schemaDecodeErr := decoder.Decode(object, req.Form)

	if schemaDecodeErr != nil {
		log.Debug("Error while decoding request ", schemaDecodeErr)
		switch err := schemaDecodeErr.(type) {
		case schema.MultiError:
			for _, errValidation := range err {
				return errValidation
			}

		default:
			return nil
		}
	}

	// validate with users validation logic for request data
	validationErrs := object.GetErrors()

	if validationErrs != nil {
		return validationErrs
	}
	return nil
}

func getRequiredFields(object reflect.Type) []string {
	var requiredFields []string
	for i := 0; i < object.NumField(); i++ {
		required := object.Field(i).Tag.Get("required")
		if required == "true" {
			param := object.Field(i).Tag.Get("json")
			requiredFields = append(requiredFields, param)
		}
		if object.Field(i).Type.Kind() == reflect.Struct && object.Field(i).Anonymous {
			requiredFields = append(requiredFields, getRequiredFields(object.Field(i).Type)...)
		}
	}
	return requiredFields
}

func checkRequiredField(object ApiRequestDTO, values map[string][]string) error {

	target := reflect.ValueOf(object).Elem().Type()
	name := target.PkgPath() + "." + target.Name()

	requiredFieldsLock.RLock()
	requiredFields, ok := requiredFieldsCache[name]
	requiredFieldsLock.RUnlock()
	if !ok {
		requiredFields = getRequiredFields(target)
		// Update cache
		requiredFieldsLock.Lock()
		requiredFieldsCache[name] = requiredFields
		requiredFieldsLock.Unlock()
	}
	for _, field := range requiredFields {
		if _, ok := values[field]; !ok {
			return fmt.Errorf("Missing required field %s", field)
		} else if len(values[field]) == 0 {
			return fmt.Errorf("Missing required field %s", field)
		}
	}
	return nil
}

func setRequestId(req *http.Request) {

	requestId := req.Header.Get(requestIDKey)

	if requestId == "" {
		// generate new uuid and assign as requestID
	}

	req.Header.Set(requestIDKey, requestId)
}
