package customer

import (
	"archive/zip"
	"bitbucket.org/kyc-agent/common/logger"
	"bitbucket.org/kyc-agent/config"
	"bitbucket.org/kyc-agent/exceptions"
	"bitbucket.org/kyc-agent/external/falcon"
	"bytes"
	"crypto/md5"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"io"
)

func getMetaData(requestId, ovoId, documentType string) (string, *exceptions.ErrorResponse) {

	logger.Info(getImageLogTag, fmt.Sprintf("fetching metadata for ovoid %s, documentType %s, requestId:%s", ovoId, documentType, requestId))
	metaDataRequest := &falcon.GetMetaDataRequest{
		MetaDataUrl: fmt.Sprintf(config.Config.Falcon.GetMetadata, config.Config.Falcon.HostPort, ovoId, documentType),
	}

	metaDataResp, err := falcon.GetMetadata(metaDataRequest, requestId)

	if err != nil {
		logger.Info(getImageLogTag, fmt.Sprintf("error while fetching metadata for image, requestId:%s", requestId))
		return "", exceptions.TransformSDKErrorToKYCError(err)
	}

	metadataId := metaDataResp[documentType][0].Id

	return metadataId, nil
}

func getImage(requestId, ovoId, documentType string) (string, *exceptions.ErrorResponse) {

	logger.Info(getImageLogTag, fmt.Sprintf("fetching image for ovoid %s, documentType %s, requestId:%s", ovoId, documentType, requestId))

	getMetadataId, err := getMetaData(requestId, ovoId, documentType)

	if err != nil {
		return falcon.NO_IMAGE, err
	}

	getImageRequest := &falcon.GetImageRequest{
		ImageUrl: fmt.Sprintf(config.Config.Falcon.GetImage, config.Config.Falcon.HostPort, getMetadataId),
	}

	imageResponse, imageErr := falcon.GetImage(getImageRequest, requestId)

	if imageErr != nil {
		return falcon.NO_IMAGE, exceptions.TransformSDKErrorToKYCError(imageErr)
	}

	logger.Info(getImageLogTag, fmt.Sprintf("successfully fetched image for ovoid %s, documentType %s, requestId:%s", ovoId, documentType, requestId))
	return string(imageResponse.Image), nil
}

// zip and upload images to falcon
func uploadZippedPictures(ovoId string, docs []docsImage, requestID string) *exceptions.ErrorResponse {

	zipFile := new(bytes.Buffer)
	zipper := zip.NewWriter(zipFile)

	var f io.Writer
	var image []byte
	var err error
	uploadErr := &exceptions.ErrorResponse{}
	// zip all the files
	for _, document := range docs {

		logger.Info(fileWriterLogTag, "compressing document: ", document.fileName)
		image, err = base64.StdEncoding.DecodeString(document.file)
		if err != nil {
			logger.Error(fileWriterLogTag, "error while decoding image string", err)
			uploadErr.Build(exceptions.ImageDecodingErrCode)
			return uploadErr
		}

		f, err = zipper.Create(document.fileName)

		if err != nil {
			logger.Error(fileWriterLogTag, "error while creating image file err: %+v", err)
			uploadErr.Build(exceptions.ImageCreateErrCode)
			return uploadErr
		}
		//fmt.Println(image)
		_, err = f.Write(image)

		if err != nil {
			logger.Error(fileWriterLogTag, "error while writing image to file err:%+v", err)
			uploadErr.Build(exceptions.ImageWriteErrCode)
			return uploadErr
		}

		logger.Info(fileWriterLogTag, "succesfully compressed document: ", document.fileName)
	}

	CloseErr := zipper.Close()

	if CloseErr != nil {
		logger.Info(fileWriterLogTag, "error while Closing zipfile err:%+v", CloseErr)
		uploadErr.Build(exceptions.ZipCloseErrCode)
		return uploadErr
	}

	md5Hash, hashErr := getMD5(zipFile)
	if err != nil {
		logger.Info(fileWriterLogTag, "Error occurred while generating md5 hash requestID: %s, err: %v", requestID, hashErr)
		uploadErr.Build(exceptions.HashGenerateErrCode)
		return uploadErr
	}
	filename := md5Hash + ".zip"

	// upload to falcon
	request := &falcon.UploadImageRequest{
		zipFile,
		filename,
		"attachment",
		ovoId,
		md5Hash,
	}

	//upload image to falcon
	_, falconErr := falcon.UploadImage(request, requestID)
	if falconErr != nil {
		return exceptions.TransformSDKErrorToKYCError(falconErr)
	}

	return nil
}

func getMD5(f io.Reader) (string, error) {
	h := md5.New()
	hbuff := bytes.NewBuffer((f.(*bytes.Buffer)).Bytes())

	if _, err := io.Copy(h, hbuff); err != nil {
		logger.Error(md5HashLogTag, "Error occurred err: %+v", err)
		return "", fmt.Errorf("Error occurred %s", err.Error())
	}

	hashInBytes := h.Sum(nil)
	hash := hex.EncodeToString(hashInBytes)

	return hash, nil
}
